# Test-Driven Development For Embedded C 

TDD не новое изобретение и существует достаточно давно. Поэтому эта книга не про объяснение концепции, а разжевывание сложившихся практик тем, кто их еще не применяет, либо применяет, но неправильно. В ней много всего, но об этом дальше. В начале хочу сказать о том, чего нет: русского языка и примеров для C++.

## Preface
Объяснения, что такое TDD, как оно работает, отличия от разработки через дебаг, а так же какие получаем преимущества. Если коротко, то:
1. в TDD существует ___микроцикл___:
- Добавь небольшой тест.  
- Запусти и посмотри, что упало (это обзятальное условие, иначе зачем нам этот тест?). Такие тесты называют ___красными___
- Сделай небольшое изменение в коде (не в тесте), чтобы тест проходил
- Запусти все тесты и убедись, что они ___зеленые___.
- Рефакторим, запускаем тесты, если они снова красные, то переходим к первому пункту.

2. Отличия и преимущества.
- Тесты автоматические и позволяют не волноваться, когда делаешь изменения
- Приходится продумывать дизайн еще до написания основного кода
- Ошибки всплывают гораздо быстрее, а исправляются проще
- Тесты - лучшая документация
- Легко встраивается в CI

## 1. Getting Started
1. Существует паттерн для тестов:
- _Setup_: сделай всю подготовительную работу.
- _Exercise_: сделай то, что тестируешь.
- _Verify_: проверь, что получилось.
- _Cleanup_: верни все, как было.

2. Боб Мартин описывает TDD, используя эти три простых правила:
- Не пиши код, если у тебя нет для него красного теста
- Не пиши больше одного красного теста за раз.
- Не пиши лишнего кода

3. TDD State Machine
![TDD State Machine](https://imgur.com/tvxx8LN.png)

4. Пиши чек-листы для тестов.
5. Tests are:
- ___F__ ast_: тесты должны быть достаточно ___быстрыми___, чтобы их можно было запускать, после любого маленького изменения. Медленные тесты никто запускать не будет.
- ___I__ solated_: тесты должны быть ___изолированы___ друг от друга. Сложно понять какой тест упал, если все они красные.
- ___R__ epeatable_: тесты должны быть ___повторяемы___. Тесты, которые при каждом запуске дают разные результат - бесполезны.
- ___S__ elf-verifying_: тесты должны ___сами себя проверять___. Если они проходят, то писать ок, если нет, то показать какой тест упал.
- ___T__ imely_: тесты должны быть ___своевременны___. Необходимо писать их перед кодом, который тестируется.

6. Для эмбедда все так же, но с некоторыми оговорками.
- Микроцикл дольше. Разработчик начинает разработку не на том, устройстве, где код реально будет исполняться. Это дает значительный выигрыш: код может начать писаться существенно раньше, чем будет готова реальная железка (и даже макет), написанные тесты помогут протестировать оборудование, такая стратегия лучше работает в большой команде, потому что позволяет работать параллельно. НО: так как разработка ведется не под нужную платформу, то могут отличаться библеотеки, компиляторы, пинауты и тд.
![enter image description here](https://imgur.com/FGgctmw.png)

7. Медленная разработка - это то, что нужно, чтобы быть быстрее!
Может казаться, что TDD существенно замедляет разработку, но на самом деле оно дает необходимые инструменты, чтобы предотвратить проблемы, которые возникнут в будущем, что дает в итоге существенное ускорение. С TDD разработка - это итеративный вдумчивый процесс, где на каждом шаге есть рабочий  и протестированный код. Его легко поддерживать и вносить изменения (если вы следуете TDD).

8. Стандартные отговорки:

- ___У нас нет на это времени___  
Но с TDD разработка получается быстрее за счет того, что время не тратится на дебаг.

- ___Почему бы не писать тесты после кода?___
Потому что тогда теряется смысл TDD. Дизайн не вырабатывается в процессе TDD, код не избавлен от многих ошибок, да и вообще тесты будут писаться так, чтобы код их проходил, либо вообще писаться не будут. Это неизбежно.

- ___Тесты надо поддерживать___
А когда тестов нет, приходится вручную проводить тесты, но это почему-то никого не смущает.

- ___Юнит тесты не находят всех багов___
Во-первых, без них еще хуже, а, во-вторых, когда происходят изменения, тесты помогают понять ничего ли не сломалось.

- ___Долгий билд___
Но целую систему билдить и не нужно. Билди только то, что нужно протестировать в данный момент.

- ___У нас есть легоси код___
И пусть. Это не мешает писать тесты для нового кода и того, который изменяется. TDD будет полезно даже в этом случае.

- ___У нас ограниченная память___
1. Используй вторую систему для разработки и запуска тестов, где памяти будет достаточно
2. Запускай тесты по частям, чтобы влезть в память
3. Используй легковесный тестовый фреймворк.

- ___У нас есть взаимодействие с хардварью___
Мокай и тестируй.

# 2. Testing Modules with Collaborators
![ddd](https://imgur.com/zTkpihg.png)

1. Некоторые причиные использовать:

- ___Независимость от hardware___
- ___Имитация трудно воиспроизводимого поведения___
- ___Имитация долгих операций___
- ___Воспроизведение необходимого контекста___
- ___Имитация того, чего еще не существует, но необходимо сейчас___

2.  Что и когда использовать?

- ___Link-time substitution___
Используется, когда хотим избавиться от зависимости от сторонних библеотек и железа.
- ___Function pointer substitution___
Использовать, когда необходимо заменить лишь некоторые функции у модуля.
- ___Preprocessor substitution___
Использовать, когда прошлые два инструмента не справляются. Например, для того, чтобы сделать private public'ом, либо чтобы переопределить функции выделения памяти.
- ___Combined link-time and function pointer substitution___
Когда нужна высокая гибкость модуля.

# 3. SOLID, Flexible, and Testable Designs

1. Design Principles

- ___S__ ingle Responsibility Principle_
Каждый модуль/функция должен делать что-то одно.

- ___O__ pen Closed Principle_
Код должен быть открыт для расширения и закрыт для изменения.

- ___L__ iskov Substitution Principle_
Модули с одинаковым интерфейсом должны вести себя одинаково.

- ___I__ nterface Segregation Principle_
Интерфейс должен быть минимальным, исходя из его названия. Если интерфейс может быть разбит на несколько отдельных - он должен быть разбит.

- ___D__ ependency Inversion Principle_
Высокоуровневые модули не должны зависить от низкоуровневых. Они должны зависить от абстракций.

2. Рефакторинг vs Refactoring vs. Humpty Dumpty design change
![](https://imgur.com/p1GeRYH.png)


# _Slow down to go fast_

Книга мне определено понравилось, но, к сожалению, книга написана именно для C. Конечно, все, что сказано справедливо и для C++, но все-таки не покрывает все возможности этого языка.
